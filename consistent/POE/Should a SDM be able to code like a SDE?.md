1. A SDM should first be a good engineer. “While officers and generals may not be expected to engage in direct combat as frequently as enlisted Marines, they are still required to maintain proficiency in marksmanship and other combat skills. In fact, Marine Corps officers are required to complete the same basic training and combat training as enlisted Marines, which includes marksmanship, close combat, and other essential combat skills.”

Problem with above things SDM should be able to code which isn't possible for other managers from PM and TPM.

1. A SDM just needs to know what questions to ask. Don’t judge, don’t be biased by your own opinions, just keep your mind empty and keep asking common questions like:

“So what do you think you can do differently?”  
“What else can you think of to make X better?”  
“Can you figure out a better way to communicate your ideas?”

This implies SDMs could be leading a team making diapers yesterday and today they can do cloud computing equally well, as long as they know what questions to ask.

Being technical can mean product vision and insight, project management skills, and software engineering techniques. On top of all these technical stuff, a SDM needs to be proficient at people management, which requires technical judgment to evaluate and grow people reporting to them.  
  
Here is the keyword, “technical judgement”. For a SDM, technical judgement is more critical than knowing all the technical details, although without sufficient details and hand on experience, having a sound technical judgement is impossible.  
  
A SDM needs to have the technical judgement of what is good and what is bad in software engineering. They use the judgement to decide “what to do, when to do what and who should do it”. They are not necessarily into the weeds of “how things are done”, but they set up  
1. Standards to judge if things are done well or not.  
2. Processes to make sure things are done in the most optimal ways.  
  
So should a SDM be “technical”? Absolutely! Should a SDM know how to code in all the components of a product, not necessarily.

